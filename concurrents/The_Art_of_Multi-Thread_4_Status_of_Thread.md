# The Art of Multi-Thread 4 —— 线程状态

### 初始态：NEW

创建一个Thread对象，但还未调用start()启动线程时，线程处于初始态。





### 运行态：RUNNABLE

在Java中，运行态包括**就绪态** 和 **运行态**。

- **就绪态**
  - 该状态下的线程已经获得执行所需的所有资源，只要CPU分配执行权就能运行。
  - 所有就绪态的线程存放在就绪队列中。
- **运行态**
  - 获得CPU执行权，正在执行的线程。
  - 由于一个CPU同一时刻只能执行一条线程，因此每个CPU每个时刻只有一条运行态的线程。





### 阻塞态

- 当一条正在执行的线程请求某一资源失败时，就会进入阻塞态。
- 而在Java中，阻塞态专指请求锁失败时进入的状态。
- 由一个**阻塞队列**存放所有阻塞态的线程。
- 处于阻塞态的线程会**不断请求资源**，一旦请求成功，就会进入**就绪队列**，等待执行。





### 等待态

- 当前线程中调用**wait**、**join**、**park**函数时，当前线程就会进入**等待态**。
- 也有一个**等待队列**存放所有等待态的线程。
- 线程处于**等待态**表示**它需要等待其他线程的指示才能继续运行**。
- 进入等待态的线程会释放CPU执行权，并释放资源（如：锁） **持有资源？？？**





### 阻塞态和等待态的区别

BLOCKED 和 WATING 的区别：

+ BLOCKED ：是在临界点外面等待进入
+ WATING ：是在临界点里面wait等待别人notify

线程调用了join方法 join了另外的线程的时候, 也会进入WAITING状态, 等待被他join的线程执行结束





### 超时等待态

- 当运行中的线程调用sleep(time)、wait、join、parkNanos、parkUntil时，就会进入该状态；
- 它和等待态一样，并不是因为请求不到资源，而是主动进入，并且进入后需要其他线程唤醒；
- 进入该状态后释放CPU执行权 和 占有的资源。
- **与等待态的区别：**到了超时时间后自动进入**阻塞队列**，开始竞争锁。





### 终止态

线程执行结束后的状态。





## 注意点

- wait()方法会释放CPU执行权 和 占有的锁 --进入**等待态**
- **sleep**(long)方法仅**释放CPU使用权，锁仍然占用**；线程被放入超时**等待队列**，与yield相比，它会**使线程较长时间得不到运行**。
- **yield**()方法仅**释放CPU执行权，锁仍然占用**，线程会被放入**就绪队列**，会在**短时间内再次执行**。
- wait和notify必须配套使用，即**必须使用同一把锁**调用；
- wait和notify必须放在一个**同步块**中
- 调用wait和notify的对象必须是他们所处同步块的锁对象。

























































































































